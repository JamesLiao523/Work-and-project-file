/** @file TutorialBase.h
* \brief Contains declaration of the CTutorialBase class
*/

#ifndef TUTORIALBASE_H
#define TUTORIALBASE_H

#include "barraopt.h"
#include "TutorialData.h"
#include <string>
#include <vector>
#include <map>

using namespace BARRAOPT;
using namespace std;

/**\brief Contains the shared routines for setting up risk model, portfolios and alpha, etc.
*/
class CTutorialBase: public CCallBack
{
public:
	CTutorialBase(CTutorialData *data);
	~CTutorialBase();

	/** set approach compatible to that prior to version 8.0
	* @param mode  If True, run optimization in the approach prior to version 8.0. 
	*/
	void SetCompatibleMode(bool mode) { m_CompatibleMode = mode; };
	
	void DumpAll(bool dumpWS) { m_DumpAll = dumpWS; };

	/** Setup initial portfolio, benchmark and trade universe
	*/
	void SetupPortfolios();

	/** Setup tax lots and recalculate portfolio weights
	*/
	void SetupTaxLots();

	/** Setup risk model data, such as factor covariance matrix, factor 
	* exposures and specific covariance
	*/
	void SetupRiskModel(bool setExposures=true);
	
	/** Setup risk model 2
	*/
	void SetupRiskModel2();

	/** Set alpha
	*/
	void SetAlpha();

	/** Set price
	*/
	void SetPrice();

	/** Run optimization
	* @param useOldSolver  If True, use the eixisting m_pSolver pointer without recreate a new solver.
	* @param estUtilUB	If True, estimate the upper bound on utility.
	*/
	void RunOptimize( bool useOldSolver=false, bool estUtilUB = false);

	/** Run optimization and report estimated utility upperbound
	*/
	void RunOptimizeReportUtilUB() { RunOptimize(false, true); };

	/** Output trade list
	* @param isOptimalPortfolio	If True, trade list info is retrieved for the optimal portfolio; 
	* otherwise trade list info is retrieved for the roundlotted portfolio.
	*/
	void OutputTradeList( bool isOptimalPortfolio=true );

	/** Returns the ID of the group which the account belongs to.
	* @param accountID the ID of the account.
	* @return the ID of the group, or -1.
	*/
	Int32 GetAccountGroupID(Int32 accountID);

	/** Callback function for handling data points generated during the efficient 
	* frontier optimization
	* @param oDataPt  A data point on the efficient frontier
	*/
	bool OnDataPoint(CDataPoint & oDataPt);

	/** Callback function for handling messages generated during efficient frontier optimization
	@param oMessage  A message generated by the optimizer
	*/
	bool OnMessage(CMessage& oMessage);

	void CollectKKT(ostream& os, double multiplier = 1.0);

protected:

	/** Initialize an optimization by calling SetupRiskModel(), SetupPortfolios() 
	* and optionally calling SetAlpha()
	*
	* @param tutorialID  Tutorial ID.
	* @param description Description of the tutorial
	* @param dumpWS If True, dump workspace to a file	
	* @param setAlpha  If True, set alpha.
	* @param setTax If True, set tax lots and wash sales.
	*/
	void Initialize( const char* tutorialID, const char* description, bool dumpWS, bool setAlpha, bool setTax);

	/** setup workspace file dumping 
	* @param tutorialID	ID of the tutorial
	* @param dumpWS		If True, dump wsp file. Otherwise no dump.
	*/
	void SetupDumpFile(const char* tutorialID, bool dumpWS);

	/** Update portfolio weights based on tax lots.
	*/
	void UpdatePortfolioWeights();

	void PrintPortfolioOutput(const CPortfolioOutput* output, bool estUtilUB = false);
	void PrintMultiAccountOutput(const CMultiAccountOutput* output);
	void PrintMultiPeriodOutput(const CMultiPeriodOutput* output);

	static void printAttributeSet(const CAttributeSet&, String title);

	CWorkSpace*		m_pWS;
	CCase*			m_pCase;
	CSolver*		m_pSolver;
	CPortfolio*		m_pInitPf;
	CPortfolio*		m_pInitPfs[CTutorialData::m_AccountNum];
	CPortfolio*		m_pBMPortfolio;
	CPortfolio*		m_pBM2Portfolio;
	CPortfolio*		m_pTradeUniverse;
	CTutorialData*  m_pData;
	//used to create a workspace dump file
	bool			m_DumpAll;
	string			m_DumpFilename;
	//used to set compatible mode to the approach prior to version 8.0 for running optimization
	bool			m_CompatibleMode;
	// portfolio values calculated from tax lots
	double			m_PfValue[CTutorialData::m_AccountNum];
};

/**\brief Contains the shared routines for collecting KKT terms.
*/
enum EKKTSide{
	KKT_SIDE_DEFAULT = 0,
	KKT_UPSIDE = 1,
	KKT_DOWNSIDE = -1
}; 

/**\brief Contains shared data structure for a KKT column.
*/
struct KKTCons{
	KKTCons(const CAttributeSet& term, String id = "", String title = "", EKKTSide side = KKT_SIDE_DEFAULT, bool pen = false);
	bool Contains(const String& id) { 	return weights.find(id)==weights.end()? false: true; };

	String displayName;
	String constraintID;
	bool isPenalty;
	EKKTSide upOrDownside; // = 1 for upside, = -1 for downside and 0 otherwise
	map<String, double> weights;
};

/**\brief Contains shared class/routines for a KKT table.
*/
class KKTData{
public:
	void AddConstraint(const CAttributeSet& attr, const String& cid, const String& title, EKKTSide side = KKT_SIDE_DEFAULT, bool pen=false);
	void AddOnlyIfDifferent(const CAttributeSet& attr, const String& cid, const String& title, EKKTSide side = KKT_DOWNSIDE, bool pen=false);
	inline void AddConstraintPenalty(const CAttributeSet& attr, const String& cid, const String& title, EKKTSide side=KKT_SIDE_DEFAULT){
		AddConstraint(attr, cid, title, side, true);
	}
	inline void AddOnlyIfDifferentPenalty(const CAttributeSet& attr, const String& cid, const String& title, EKKTSide side = KKT_DOWNSIDE){
		AddOnlyIfDifferent(attr, cid, title, side, true);
	}

	friend ostream& operator<<(ostream& output, const KKTData& d);

private:
	vector<KKTCons> kkt;
};

#endif
